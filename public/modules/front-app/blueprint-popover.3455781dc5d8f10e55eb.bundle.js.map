{"version":3,"sources":["webpack:///./node_modules/@blueprintjs/popover2/lib/esm/contextMenu2.js","webpack:///./resources/modules/front-app/src/js/libs/blueprint-popover.js"],"names":["ContextMenu2","props","userRef","_a","_b","className","children","content","_c","disabled","onContextMenu","popoverProps","_d","tagName","restProps","_e","undefined","targetOffset","setTargetOffset","_f","mouseEvent","setMouseEvent","_g","isOpen","setIsOpen","containerRef","cancelContextMenu","e","preventDefault","handlePopoverInteraction","nextOpenState","targetRef","renderTarget","ref","style","isDarkTheme","current","contentProps","menu","maybePopover","enforceFocus","key","getPopoverKey","hasBackdrop","minimal","onInteraction","popoverClassName","placement","positioningStrategy","rootBoundary","transitionDuration","handleContextMenu","defaultPrevented","persist","targetElement","containingBlock","closest","getBoundingClientRect","left","top","getContainingBlockOffset","top_1","clientX","clientY","containerClassName","popover","displayName","window","altrpLibs","BlueprintPopover"],"mappings":"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","file":"blueprint-popover.3455781dc5d8f10e55eb.bundle.js","sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Classes as CoreClasses, Utils as CoreUtils, mergeRefs, } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport { Popover2 } from \"./popover2\";\nexport var ContextMenu2 = React.forwardRef(function (props, userRef) {\n    var _a;\n    var _b;\n    var className = props.className, children = props.children, content = props.content, _c = props.disabled, disabled = _c === void 0 ? false : _c, onContextMenu = props.onContextMenu, popoverProps = props.popoverProps, _d = props.tagName, tagName = _d === void 0 ? \"div\" : _d, restProps = __rest(props, [\"className\", \"children\", \"content\", \"disabled\", \"onContextMenu\", \"popoverProps\", \"tagName\"]);\n    var _e = React.useState(undefined), targetOffset = _e[0], setTargetOffset = _e[1];\n    var _f = React.useState(), mouseEvent = _f[0], setMouseEvent = _f[1];\n    var _g = React.useState(false), isOpen = _g[0], setIsOpen = _g[1];\n    var containerRef = React.useRef(null);\n    // If disabled prop is changed, we don't want our old context menu to stick around.\n    // If it has just been enabled (disabled = false), then the menu ought to be opened by\n    // a new mouse event. Users should not be updating this prop in the onContextMenu callback\n    // for this component (that will lead to unpredictable behavior).\n    React.useEffect(function () {\n        setIsOpen(false);\n    }, [disabled]);\n    var cancelContextMenu = React.useCallback(function (e) { return e.preventDefault(); }, []);\n    var handlePopoverInteraction = React.useCallback(function (nextOpenState) {\n        if (!nextOpenState) {\n            setIsOpen(false);\n            setMouseEvent(undefined);\n        }\n    }, []);\n    var targetRef = React.useRef(null);\n    var renderTarget = React.useCallback(function (_a) {\n        var ref = _a.ref;\n        return (React.createElement(\"div\", { className: Classes.CONTEXT_MENU2_POPOVER2_TARGET, style: targetOffset, ref: mergeRefs(ref, targetRef) }));\n    }, [targetOffset]);\n    var isDarkTheme = React.useMemo(function () { return CoreUtils.isDarkTheme(targetRef.current); }, [targetRef.current]);\n    var contentProps = { isOpen: isOpen, mouseEvent: mouseEvent, targetOffset: targetOffset };\n    // only render the popover if there is content in the context menu;\n    // this avoid doing unnecessary rendering & computation\n    var menu = disabled ? undefined : CoreUtils.isFunction(content) ? content(contentProps) : content;\n    var maybePopover = menu === undefined ? undefined : (React.createElement(Popover2, __assign({}, popoverProps, { content: \n        // this prevents right-clicking inside our context menu\n        React.createElement(\"div\", { onContextMenu: cancelContextMenu }, menu), enforceFocus: false, \n        // Generate key based on offset so that a new Popover instance is created\n        // when offset changes, to force recomputing position.\n        key: getPopoverKey(targetOffset), hasBackdrop: true, isOpen: isOpen, minimal: true, onInteraction: handlePopoverInteraction, popoverClassName: classNames(popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.popoverClassName, (_a = {}, _a[CoreClasses.DARK] = isDarkTheme, _a)), placement: \"right-start\", positioningStrategy: \"fixed\", rootBoundary: \"viewport\", renderTarget: renderTarget, transitionDuration: (_b = popoverProps === null || popoverProps === void 0 ? void 0 : popoverProps.transitionDuration) !== null && _b !== void 0 ? _b : 100 })));\n    var handleContextMenu = React.useCallback(function (e) {\n        // support nested menus (inner menu target would have called preventDefault())\n        if (e.defaultPrevented) {\n            return;\n        }\n        // If disabled, we should avoid this extra work. Otherwise: if using the child function API,\n        // we need to make sure contentProps is up to date for correctness, so we handle the event regardless\n        // of whether the consumer returned an undefined menu.\n        var shouldHandleEvent = !disabled && (CoreUtils.isFunction(children) || maybePopover !== undefined);\n        if (shouldHandleEvent) {\n            e.preventDefault();\n            e.persist();\n            setMouseEvent(e);\n            var _a = getContainingBlockOffset(containerRef.current), left = _a.left, top_1 = _a.top;\n            setTargetOffset({ left: e.clientX - left, top: e.clientY - top_1 });\n            setIsOpen(true);\n        }\n        onContextMenu === null || onContextMenu === void 0 ? void 0 : onContextMenu(e);\n    }, [containerRef.current, onContextMenu, disabled]);\n    var containerClassName = classNames(className, Classes.CONTEXT_MENU2);\n    if (CoreUtils.isFunction(children)) {\n        return children({\n            className: containerClassName,\n            contentProps: contentProps,\n            onContextMenu: handleContextMenu,\n            popover: maybePopover,\n            ref: containerRef,\n        });\n    }\n    else {\n        return React.createElement(tagName, __assign({ className: containerClassName, onContextMenu: handleContextMenu, ref: mergeRefs(containerRef, userRef) }, restProps), maybePopover, children);\n    }\n});\nContextMenu2.displayName = \"Blueprint.ContextMenu2\";\nfunction getContainingBlockOffset(targetElement) {\n    if (targetElement != null) {\n        var containingBlock = targetElement.closest(\".\" + CoreClasses.FIXED_POSITIONING_CONTAINING_BLOCK);\n        if (containingBlock != null) {\n            return containingBlock.getBoundingClientRect();\n        }\n    }\n    return { left: 0, top: 0 };\n}\nfunction getPopoverKey(targetOffset) {\n    return targetOffset === undefined ? \"default\" : targetOffset.left + \"x\" + targetOffset.top;\n}\n//# sourceMappingURL=contextMenu2.js.map","import * as BlueprintPopover from '@blueprintjs/popover2'\r\nimport \"../../../../editor/src/sass/blueprint-popover.scss\";\r\n(window.altrpLibs = window.altrpLibs || {}).BlueprintPopover = BlueprintPopover;\r\n\r\n"],"sourceRoot":""}